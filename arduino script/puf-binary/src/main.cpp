#include "Arduino.h"
#include <stdio.h>
#include <Tools.h>
#include <BCH.h>
#include <SPI.h>

#define RDSR        5
#define WRSR        1
#define READ        3
#define WRITE       2

byte cs_pin = 10; //cs_pin location of the two SRAMS
uint32_t maxpage = 4096;  //number of pages in 23LC1024 SRAM
uint32_t i, j, n;
uint32_t value;
uint32_t num = 0;
uint32_t total_send = 10;
// uint8_t buff[32];
uint32_t index = 0;
uint8_t key_256[] = {0xd2, 0xf, 0x56, 0x56, 0xbf, 0x43, 0x65, 0x16, 0xcd, 0xf, 0x3d, 0x2e, 0x73, 0x48, 0x51, 0xdc,
                         0x53, 0x7d, 0xf5, 0x18, 0x97, 0x48, 0x41, 0x28, 0xcc, 0xae, 0x67, 0xee, 0x13, 0x10, 0xf6,
                         0x9b,};
long puf_index_default[] = {52888, 52920, 53136, 53168, 53384, 53416, 53632, 53664, 75864, 76112, 76360, 76608, 22648, 22896, 23144, 23392, 52952, 53200, 53448, 53696, 22584,
  23080, 23328, 11544, 11792, 12040, 12288, 22616, 22864, 23112, 23360, 33240, 33488, 33736, 33984, 115800, };
  uint8_t puf_binary_default[37*8] = {
    0x0, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0xFB, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0x62, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB,
                    0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x35, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
                    0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
                    0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC, 0xEC,
                    0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0x34, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0xB5, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
                    0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xD1, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xF9, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6,
                    0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x3E, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
                    0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0xE9, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,

                    0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF, 0xEF,
                    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
                    0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0x2F, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD9, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3, 0xD3,
                    0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67, 0x67,
                    0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0,
    };
uint8_t helper_data[] = {
  0x13, 0xd1, 0xfc, 0x25, 0x8e, 0x7e, 0x3d,
0x8d, 0x58, 0xa0, 0x81, 0xb, 0x71, 0x48,
0x47, 0xab, 0x7e, 0x86, 0xa7, 0x2d, 0x57,
0x75, 0xce, 0xfb, 0x85, 0x8d, 0xef, 0x71,
0x7b, 0xd, 0x67, 0x9b, 0x8b, 0x4e, 0x73,
0xf7, 0x48, 0x4c, 0x7d, 0x32, 0x75, 0x50,
0xae, 0x6f, 0x63, 0x30, 0xe1, 0x28, 0x46,
0x95, 0x2e, 0x1b, 0x65, 0x6d, 0xf, 0x91,
0xcd, 0xe4, 0xc, 0xe8, 0x5f, 0x39, 0x96,
0xdf, 0x68, 0xe, 0xa1, 0x60, 0x6c, 0x3f,
0xc9, 0x39, 0x7a, 0x6e, 0x9a, 0xe8, 0xb3,
0x40, 0xc2, 0xda, 0x7d, 0xde, 0x4c, 0x91,
0x27, 0x1e, 0x33, 0xea, 0x41, 0xb1, 0xf2,
0x98, 0x6c, 0x1e, 0x45, 0xf6, 0xa1, 0x41,
0xae, 0xc0, 0xd, 0x52, 0xd0, 0xc8, 0x6f,
0x48, 0x81, 0xef, 0x22, 0x7d, 0xff, 0xe7,
0xe6, 0x80, 0x2f, 0xee, 0xe2, 0xb1, 0x60,
0x5b, 0xa7, 0xb7, 0x72, 0x4f, 0x53, 0xc5,
0x5e, 0x1d, 0x9, 0xfd, 0x8f, 0xd4, 0x67,
0x58, 0x91, 0xff, 0x32, 0x6d, 0xef, 0xf7,
0x7a, 0x82, 0xa3, 0x29, 0x53, 0x6a, 0x47,
0xe6, 0x55, 0x2, 0xe2, 0x64, 0x4d, 0xa5,
0x79, 0x71, 0x13, 0x8d, 0x3, 0x48, 0x3e,
0x1b, 0x48, 0x99, 0x50, 0x3e, 0xf3, 0xac,
0x7d, 0x99, 0x2e, 0x48, 0xe7, 0x26, 0x2a,
0x45, 0xbd, 0x9c, 0x16, 0x6c, 0x55, 0x78,
0x54, 0xda, 0x91, 0xe7, 0x8d, 0x71, 0x61,
0x73, 0xf1, 0xe9, 0x4e, 0xed, 0x7f, 0xa2,
0x52, 0xe9, 0xdc, 0xa2, 0xaa, 0xc8, 0x56,
0xbd, 0x49, 0x3b, 0x60, 0xd3, 0x84, 0x64,
0x68, 0xa, 0x94, 0x1a, 0x51, 0x27, 0x4d,
0x14, 0x86, 0x5b, 0xc1, 0x7e, 0x7a, 0x4b,
0x46, 0xd0, 0x3c, 0xe9, 0x11, 0x30, 0xba,
0xbd, 0xf6, 0x80, 0xea, 0x16, 0x6, 0xc3,
0xc0, 0x5, 0x38, 0x24, 0xb2, 0x5e, 0x8b,
0x74, 0x4d, 0x60, 0xb9, 0x12, 0xe2, 0xa1,
0xbc, 0x8d, 0xc2, 0x85, 0xa0, 0x1b, 0x2e,
};

uint8_t puf_binary_new[8*37];
int inByte;

int pin_hold = 11;
int pin_select = 10;
int pin_mosfet = 12;
int pin_power = 8;

void print_binary(uint8_t v)
{
    int num_places = 8;
    int mask=0, n;

    for (n=1; n<=num_places; n++)
    {
        mask = (mask << 1) | 0x0001;
    }
    v = v & mask;  // truncate v to specified number of places

    while(num_places)
    {
        if (v & (0x0001 << num_places-1))
        {
             Serial.print("1");
        }
        else
        {
             Serial.print("0");
        }

        --num_places;
        Serial.print(", ");
    }
}

uint8_t Spi23LC1024Read8(uint32_t address, uint8_t cs_pin)
{
  uint8_t read_byte;

  digitalWrite(cs_pin, LOW);
  SPI.transfer(READ);
  SPI.transfer((uint8_t)(address >> 16));
  SPI.transfer((uint8_t)(address >> 8) & 0xFF);
  SPI.transfer((uint8_t)address);
  read_byte = SPI.transfer(0x00);
  digitalWrite(cs_pin, HIGH);

  return read_byte;
}

void readSRAM(){
  uint8_t result;

  SPI.begin();
  digitalWrite(pin_select, LOW);
  digitalWrite(pin_hold, HIGH);
  digitalWrite(pin_mosfet, HIGH);
  digitalWrite(pin_power, HIGH);
  delay(100);

  // read
  index = 0;
  for (i = 0; i < 37; i++)
  {
    for (j = 0; j < 8; j++){
      result = Spi23LC1024Read8(puf_index_default[i], cs_pin);
      puf_binary_new[index] = result;
      // Serial.print("0x");
      // Serial.print(puf_binary_new[index], HEX);
      // Serial.print(",");
      // Serial.print("0x");
      // Serial.print(puf_binary_default[index], HEX);
      // Serial.print(" - ");
      index++;
      // Serial.println();
    }
    // if ((i+1)%3==0)
    //   Serial.println();
  }


  digitalWrite(pin_select, HIGH);
  //  digitalWrite(pin_hold, LOW);
  digitalWrite(pin_hold, HIGH);
  digitalWrite(pin_mosfet, LOW);
  digitalWrite(pin_power, LOW);

  SPI.end();
}

int difference_bin_array(uint8_t a[], uint8_t b[], int size) {
    int count = 0;
    int index = 0;
    int shift = 0;
    for (int i = 0; i < size; i++) {
        shift = (7 - (i % 8));
        // Serial.print((a[index] >> shift) & 0x1);
        // Serial.print((b[index] >> shift) & 0x1);
        // Serial.print(" ");
        if (((a[index] >> shift) & 0x1) != ((b[index] >> shift) & 0x1)) {
            count++;
        }
        if ((i + 1) % 8 == 0)
            index++;
    }
    // Serial.println();
    return count;
}

void check_difference(){
  Serial.println();
  int max_diff = 0;
  int max_idx = 0;
  int diff=0;
  for (i=0;i<37;i++){
    // Serial.print(i);
    // Serial.print(" - ");
    diff = 0;
    for (j =0;j<8;j++){
      diff += difference_bin_array(&puf_binary_new[i], &puf_binary_default[i], 8);
      // Serial.print(diff);
      // Serial.println(", ");
      // Serial.print((int) &puf_binary_new[i], HEX);
      // Serial.print(", ");
      // Serial.print((int) &puf_binary_default[i], HEX);
      // Serial.println();
      if (diff > max_diff){
        max_diff = diff;
        max_idx = i;
      }
    }
    // Serial.print(diff);
  }
  Serial.print("Max difference: ");
  Serial.println(max_diff);
  Serial.print("Max index: ");
  Serial.println(max_idx);
}

void set(){
  Serial.begin(9600);

  delay(1000);

  pinMode(LED_BUILTIN, OUTPUT);

  pinMode(pin_select, OUTPUT);
  pinMode(pin_hold, OUTPUT);
  pinMode(pin_mosfet, OUTPUT);
  pinMode(pin_power, OUTPUT);
}

uint8_t encoded_new[8*37];
uint8_t xor_enroll_new[8*37];
uint8_t helper_data_new[7*37];
uint8_t helper_data_padded_new[8*37];
uint8_t xor_reproduction_new[8*37];
uint8_t reconstructed_key_new[37];
uint8_t key_per_row[37];

BCH bch;
Tools tools;

void decode(){
  memset(helper_data_padded_new, 0, sizeof(helper_data_padded_new));
  memset(xor_reproduction_new, 0, sizeof(xor_reproduction_new));
  memset(reconstructed_key_new, 0, sizeof(reconstructed_key_new));
  memset(key_per_row, 0, sizeof(key_per_row));

  int row = 37;
  int n = bch.get_n();
  int k = bch.get_key_length();

  int k_length_bit = row;//tools.ceil(k*row,8);
  int n_length_bit = row * 8;//tools.ceil(n*row,8);

  /************************************
   ****** REPRODUCTION PROCEDURE ******
   ************************************/
  /******************** ASSERT HELPER DATA PADDED**********************/
  Serial.println("HELPER DATA PADDED");
  for (i = 0; i < row; i++) {
      memcpy(&helper_data_padded_new[i * 8], &helper_data[i * 7],
             7 * sizeof(uint8_t));
  }

  /******************** ASSERT XOR REPRODUCTION **********************/
  Serial.println("XOR REPRODUCTION");
  for (i = 0; i < row; i++) {
     for (j = 0; j < 8; j++) {
       // xor_reproduction_new[i*8 + j] = puf_binary_new[i*8 + j] ^ helper_data_padded_new[i*8 + j];
       xor_reproduction_new[i*8 + j] = puf_binary_default[i*8 + j] ^ helper_data_padded_new[i*8 + j];
     }
  }

  /******************** ASSERT RECONSTRUCTED KEY **********************/
  Serial.println("RECONSTRUCTED KEY");
  int8_t input[64];
  for (i = 0; i < row; i++) {
      memset(input, 0, sizeof(input));
      tools.convert_uint8_array_to_bin_array(&xor_reproduction_new[i*8], input, 8);
    // bch.decode_bch(&xor_reproduction_new[i * 8], &reconstructed_key_new[i]);
      bch.decode_bch_old(input, &reconstructed_key_new[i]);
      // tools.print_binary(reconstructed_key_new[i]);
      // Serial.println();
  }

  tools.gen_key_per_row(key_256, key_per_row);

  for (i = 0; i < row; i++) {
    Serial.print(i);
    Serial.print(" - ");
    tools.print_binary(key_per_row[i]);
    Serial.print(" ");
    tools.print_binary(reconstructed_key_new[i]);
    if (key_per_row[i] == reconstructed_key_new[i]){
      Serial.println(" TRUE");
    }else{
      Serial.println(" FALSE");
    }
  }
}

void setup(void)
{
  set();

  Serial.println("READ");

  readSRAM();
  check_difference();

  Serial.println("START PUF DECODE");

  bch = BCH();
  tools = Tools();
  bch.initialize();               /* Read m */

  decode();
}



void loop(){

}
